{
  "name": "nodestalker",
  "description": "A Beanstalk client for node.js",
  "keywords": [
    "beanstalkd",
    "queue"
  ],
  "version": "0.1.4",
  "author": {
    "name": "Pascal Opitz",
    "email": "contact@pascalopitz.com",
    "url": "http://blog.pascalopitz.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/pascalopitz/nodestalker.git"
  },
  "main": "./lib/beanstalk_client",
  "dependencies": {
    "yaml": ""
  },
  "scripts": {
    "test": "find tests/ | grep .js | xargs -n1 node"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/pascalopitz/nodestalker/raw/master/LICENSE"
    }
  ],
  "readme": "A Beanstalk client utilising node.js\nTested for beanstalkd 1.4.6\n\n## INSTALL\n\n    npm install nodestalker\n\n\n## USAGE\n\nSimple usage example:\n\n    var bs = require('nodestalker'),\n        client = bs.Client();\n\n    client.use('default').onSuccess(function(data) {\n      console.log(data);\n\n      client.put('my job').onSuccess(function(data) {\n    \tconsole.log(data);\n    \tclient.disconnect();\n      });\n    });\n\n\n\n\n### How do I reserve multiple items?\n\nEach client basically represents one open socket to beanstalkd. \nEach command call just pumps one command into that socket, which then expects a corresponding return.\n\nThe server should maintain the state of the socket. \nHowever, reserve (or reserve with timeout) will only pull one job. \nYou should then be able to reserve again on the same socket with the state of watch and ignore still preserved by the server.\n\nProbably the most common usage scenario:\n\n    var bs = require('nodestalker'),\n        client = bs.Client(),\n        tube = 'test_tube';\n\n    client.watch(tube).onSuccess(function(data) {\n        function resJob() {\n            client.reserve().onSuccess(function(job) {\n                console.log('reserved', job);\n\n                client.deleteJob(job.id).onSuccess(function(del_msg) {\n                    console.log('deleted', job);\n                    console.log('message', del_msg);\n                    resJob();\n                });\n            });\n        }\n\n        resJob();\n    });\n\nIf you want to do this fully in a fully asynchronous way, because there's a blocking process happening otherwise, you'll have to work with multiple sockets.\nThis means that you'll have to repeat watch and ignore commands for each socket.\n\n    var bs = require('nodestalker'),\n        tube = 'test_tube';\n\n    function processJob(job, callback) {\n        // doing something really expensive\n        console.log('processing...');\n        setTimeout(function() {\n            callback();\n        }, 1000);\n    }\n\n    function resJob() {\n        var client = bs.Client();\n\n        client.watch(tube).onSuccess(function(data) {\n            client.reserve().onSuccess(function(job) {\n                console.log('received job:', job);\n                resJob();\n\n                processJob(job, function() {\n                    client.deleteJob(job.id).onSuccess(function(del_msg) {\n                        console.log('deleted', job);\n                        console.log(del_msg);\n                        client.disconnect();\n                    });\n                    console.log('processed', job);\n                });\n            });\n        });\n    }\n\n    resJob();\n\n\n## DOCUMENTATION\n\nAnnotated source in the docs folder\n\n## TESTING\n\nAlso there are some tests now.\nPlease make sure beanstalkd is running on the default settings.\n\nTo run all tests:\n\n    npm test\n\n\n## CREDIT\n\nDepends on the yaml package by visionmedia.\n\nhttps://github.com/visionmedia/js-yaml\n\nThanks to people that took time to fix some things.\n\naahoughton\n\n",
  "readmeFilename": "README.md",
  "_id": "nodestalker@0.1.4",
  "dist": {
    "shasum": "cfc0e18700ac0d764d9531ef49ceb26daab3106e"
  },
  "_from": "nodestalker"
}
